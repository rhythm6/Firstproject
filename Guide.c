//注 : 本文件 只写操作方法 和部分知识点 因为以前的文件被我做掉了
#define _CRT_SECURE_NO_WARNINGS //找到安装目录下的newc++.cpp文件第一行编辑 #define _CRT_SECURE_NO_WARNINGS 1 就会自动生成这个
//ctrl+shift+L 删除所有选定行 若没有选定行则删除当前行
//ctrl+shift+U 编辑转大写
//ctrl+U	   编辑转小写
//ctrl+Enter  上开新行
//ctrl+shift+Enter 该点处加新行
//ctrl+shift+左右方向键) 编辑选定单词
//搜索文本的下一个匹配项 F3
//ctrl+END 将插入点移动到文档的最后一行
//ctrl+HOME 将插入点移动到文档首行
//ctrl+TAB 逐个窗口地循环通过MDI子窗口(就是上面的文件可以切换)
//选中后ctrl按住  按k+c 快速注释
//ctrl按住 k+u 解除注释
//ctrl d 复制当前行
//注意 函数写到return 0;后面就没用了 
//注意 变量定义一定要写在函数前面 否则老的编译器可能会报错 vs2019可以正常运行
//Git和 TortoiseGit 安装一路默认即可 若TortoiseGit 安装报错 是因为权限没给 ctrl+shift+esc 打开任务管理器 ->文件 执行新任务 
//勾选以系统权限创建次任务 进行安装
/* return 只能同时返回一个数(这个数可以由其他数算出) 例:return start-end;
* 帮助-> 添加和删除帮助内容 找Visual C++里面有库函数介绍 和其他介绍
* 切换项目选择打开sln结尾的文件 
调试程序 按F10开始 F11开始逐步运行 按一次走一步  想观察什么值自己创建 退出按F5
 1  字符处理 ctype.h
 2  地区化 local.h
 3  数学函数 math.h
 4  信号处理 signal.h
 5  输入输出 stdio.h
 6  实用工具程序 stdlib.h
 7 字符串处理 string.h
 8 系统定义函数 windows.h

 选中函数 鼠标右键 转到定义 可以查看该函数的值
 printf("%d\n",'\n');打印出\n的ASCII值
 EOF - end of file 文件结束标志
 continue 符合条件就跳出(本次 本次 本次)循环 继续下一次循环
 putchar(参数) 用来输出 跟printf类似
 sizeof 计算所有元素所占的空间包括隐藏的\0 -操作符
 strlen 只求字符长度 \0 之前的字符个数 -库函数 要引头文件
 for 循环:
 for(表达式1;表达式2;表达式3)
 表达式1 用于初始化循环变量 表达式2 条件判断部分 表达式3位调整部分 用于循环条件的调整
 注：表达式3是符合条件判断部分后 执行一次循环 再执行(重点)
 循环语句
 当判断条件省略时，就变成死循环
 1 初始化变量 2 判断条件是否为真 为真 执行循环体  3再次判断 直到条件为假 结束循环
 
 1 不可在for循环体内修改循环变量,防止for循环失去控制 例practice1 116-127
 2 建议for语句的循环控制变量的取值采用"前闭后开区间"写法 practice1 129-138
 
 LINK : fatal error LNK1168: 无法打开 无法写入 
原因:遇到这种情况，一般是vs进行图片读写时上一次程序占用没有彻底关闭，
解决方法:此时需要做的是 打开任务管理器，找到该进程，杀死他，再编译，就会发现编译通过。
要是找不到进程 直接找到文件用电脑管家粉碎即可
因为每次VC都会先删除这个exe文件 再重新创建 下一次启动前 上一个进程还在执行 就无法正常启动

 C6301; 返回值被忽略 scanf
 原因: scanf()在读取时不检查边界，所以可能会造成内存访问越界
 解决方法:直接把scanf()换成scanf_s()。
 最新的VS2019中提供了scanf_s()。在调用时，可以提供一个数字以表明最多读取多少位字符。
与原scanf区别:  例:scanf_s("%c,%c",&c1,1,&c2,1);   不能写成scanf_s("%c,%c",&c1, &c2,1, 1);否则编译器会报错。
*/

/*
do {
 循环语句
}while(判断条件);
无论如何先执行一次循环 再判断 所以用的少
#define 不是关键字 它是预处理指令
指针大小要不是4个字节(32位操作系统) 要不是8个字节(64位操作系统)
static 的作用是改变变量的作用域 可以让他被其他源文件或者是函数调用
同时这个变量作用域会变大
if语句是一种分支语句 可以实现单分支，也可以实现多分支
0表示假 非0表示真 不是1表示真
char 字符对应的是ACSII码 值也可以表示整形 唯独单精度双精度浮点型不行
	scanf("%d%d%d", &a, &b, &c); //&前面有个空格不能少
		//因为它会把每个字符的结尾的那个\n给抵消掉
		//若是%d,%d,%d 那么输入字符的时候也是字符1，字符2，字符3
条件表达式的执行次数总是比循环体的执行次数多一次
	
时间戳:
当前计算机器的时间-计算机的起始时间（1970.1.1:0:00）=(xxx)秒
随着计算机时间一直改变
goto 语句
用法:goto 跳出名称;
跳出名称:
适合场景
for(...)
	for(...)
		for(...)
		{
		if(disaster)//如果发生严重错误
			goto error;//跳到这里去
			}
			}
			...
		error:
		if(disaster)
			//处理错误情况

函数定义
自定义函数(先想好这个函数怎么用，再去实现函数)
ret_type fun_name(para1,*)          int Add(intx,int y)
{		statement://语句项		    {
             }                       int z = 0;
ret_type 返回类型                    z = x+y;
fun_name 函数名                      return z;
para1    函数参数                    }


指针变量是用来接收地址的
*pa = 20;//解引用操作 也是赋值的用法
 &符号放在一个变量声明或者是函数的形参声明前就是引用
如果放在一个已经定义的变量前，就是取地址
	
函数的参数
实际参数（实参）:
真正传给函数的参数，叫实参。实参可以是:常量、变量、表达式、函数等
无论实参是何种类型的量，在进行函数调用时，他们都必须有确定的值，以便把这些值传送给形参。

形式参数（形参）:
形式参数是指函数名后括号中的变量(前半句是重点 一般是自定义的函数括号内的叫形参 例:parctice_.c 393 402行)，
因为形式参数只有在函数被调用的过程中才实例化（分配内存空间）
所以叫形式参数，当函数调用完之后形式参数自动销毁，因此形式参数只在函数中有效

(当实参传给形参时)
形参实例化之后相当于实参的一份临时拷贝
对形参的修改不会改变实参

函数的调用:
传值调用
函数的形参和实参分别战友不用的内存块，对形参的修改不会影响实参。

传址调用:
&元素名
传值调用是把函数外部创建的变量的内存地址传递给函数参数的一种调用函数
这种传参方式可以让函数和函数边的变量建立起真正的联系，（也就是函数内部可以直接调用函数外部的变量）

函数声明 若定义的函数写在主函数后 声明函数就不会报错(错误原因 程序是从前往后开始执行) 
例:int Add(int x, int y);
注:VS2019就算定义的函数写在主函数后且未声明 也可以正常使用 但是还是按照正常的顺序写比较好 在各个版本都能用
常用的用法是 在一个专门定义函数的源文件中定义函数 然后在头文件里声明函数 
其他源文件就可以用"头文件名称.h"来直接调用 注意是双引号
原因:代码复用性高 在团队上可以同时开发 各做各的功能模块
	
递归算法: 自己调用自己
递归的主要思考方式:大事化小
递归存在限制条件:让递归停下来
每次递归调用之后越来越接近这个限制条件
递归算法很容易栈溢出(Stack overflow)
《剑指offer》 67道算法笔试题

数组:
数组是一组相同类型元素的集合
元素类型 数组名 [数组元素个数]
数组在内存中是连续存放的 几维都一样
数组下标从0开始
数组的行/列的下标也是从0开始
数组名是数组首元素的地址但有俩个例外
1 sizeof（arr）此时数组名表示整个数组 单位是字节
2 (&取地址符)&arr 数组名代表整个数组 取出的是整个数组的地址

对于整形来说: 数据在内存中是以补码方式存储 
一、正整数的原码、反码、补码完全一样，即符号位固定为0，数值位相同。
二、负整数的符号位固定为1，由原码变为补码时，规则如下：
1、原码符号位1不变，整数的每一位二进制数位求反，得到反码。
2、反码符号位1不变，反码数值位最低位加1，得到补码。

8421码十进制转二进制
1          1          1          1          1          1          1          1
表达的意思是每一个2进制的1表示一个固定的数字，只需要将固定的值相加，即可得到十进制的值 例101 = 1+0+4=5
128		   64         32         16         8          4          2          1

补码与原码转换 其运算过程相同
使用补码可以将符号位和数组位统一处理
CPU只有加法器  其他运算都用加法来演示出来的

无符号数:原码，反码，补码相同(重要)

多个字节安排的的问题
大端字节序存储模式(大端存储):数据的低位保存在内存的高地址  高位保存在低地址 例a=1 16进制就是   0x 00 00 00 14      00 00 00 14
小端字节序存储模式(小端存储):数据的低位保存在内存的低地址  高位保存在高地址					                       14 00 00 00  
//数据左边是高位，右边是低位
为什么用大小端 因为若首个数字从中间开始放 那么无论是存数据 还是取数据 都很复杂 所以从俩头存取更好


操作符: 算术运算符 + - * / % 其中 / 得到的结果是商数 而%得到的是余数
右移操作符: 移动的是相应的二进制位   >> 算术右移:右边丢弃，左边补上原符号位(首位) 首位是0是正数,1是负数 常用这个
逻辑右移:右边直接丢弃,左边补0 ,移位不能移动负数 num >> -1;//error ，只能作用于整数型
左移操作符 << 左边丢弃 右边补0
practice4.c  row:154

扩展插件手动安装方法
https://blog.csdn.net/u013986317/article/details/114226288
1.首先退出所有Visual Studio
2.cmd 命令切换到Visual Studio2019程序目录，也就是VSIXInstaller.exe程序所在目录，
如果vs安装在别的盘，跳转目录时，需要先输入“D:”
3.然后输入：VSIXInstaller.exe（空格）vsix文件全路径；按回车进入安装界面；

指针 practice_5
指针是什么，在计算机科学中,指针是编程语言中的一个对象,利用地址,它的值直接指向
存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元,可以说,地址指向该变量单元.
因此，将地址形象化位"指针".意思是通过他能找到以它为地址的内存单元。
指针是个变量 里面存放的是地址

一个小的单元是一个字节大小
如何编址: 一个字节给一个对应的地址 32位机器32根地址线 产生的地址是 
00000000 00000000 00000000 00000000 
....... 一直到
11111111 11111111 11111111 11111111
总共有2^32个地址 2^32Byte == 2^32/1024kB == 2^32/1024/1024 MB = 2^32/1024/1024/1024GB = 4GB
4G的空闲进行编址
同理 64位空间是 8GB 32位平台 一个指针4个字节 64位平台 一个指针8个字节
结构体:practice_6 
struct tag  struct(结构体关键字) tag 结构体标签 struct tag 结构体类型
{
member-list; member 结构体成员名
}variable-list; variavle 结构体变量名 这个地方创建的是全局变量 不建议使用
结构体的成员 可以是变量,数组,指针，甚至是其他结构体。
practice_6.c 50行
struct Point
{
int x;
int y;
}pl;//声明类型的同时定义变量p1
stuct Point p2 //定义结构体变量p2

//初始化，定义变量同时赋值
struct Point p3 = {x,y};
struct Stu
{
}

实用调试技巧 (找bug)
所有发生的事情一定有迹可循,，每一次调试都是尝试破案的过程。
调试的基本步骤
发现程序错误存在   (若被测试出自己的代码有bug,承认错误)
以隔离,消除等方式对错误进行定位
确定错误产生的原因
提出纠正错误的解决办法
对程序错误改正，重新测试
debug Debugging /Debug  调试版本 不做优化 方便调试
release 发布版本 做了最好的优化 程序测试 测试release版本 不能调试

F5启动调试 v2019直接按好像没用 但设置断点后有用
F9创建断点  用F5直接运行到断点停止
F10 逐过程 一个过程可以是一个语句 一次函数调用 
F11 逐语句 每次只执行一条语句 (最常用的)
CTRL + F5 开始执行 不调试
自动窗口 调试时 程序运行到哪 自动窗口就会自动添加变量值 
局部变量 跟自动窗口相似 当出了上一个函数 上一个函数的值就看不到了 不能自己添加变量值
内存 查看内存 &变量名(用的很多)
调用堆栈 可以查看函数调用的逻辑 (非常详细)
常见的coding技巧(code编码 - coding)
1使用assert(断言)  要引入头文件#include<assert.h>
2尽量使用const(常量
3养成良好的编码风格
4添加必要的注释
5避免编码的陷阱
practic_6 235 示范

ctrl + F7 编译代码后 双击报错信息快速找到错误行
无法解析的外部符号  链接错误  一般是标识名(调用函数名)错误  或者函数压根不存在
做一个有心人,积累排查经验

数据的存储
C语言类型
1内置类型 char short int long float double
2自定义类型(构造类型)
整型家族:
char  
	unsigned char  无符号char型  没有符号位 计算把符号位也计算在内 
	signed char	   有符号char型  无符号值范围大于有符号
short
	unsigned short[int]  [int]可省略
	signed short[int]
int 
	unsigned int
	signed int
long 
	unsigned long[int]
	signed long[int]

浮点型家族
float
double

构造类型(自定义类型)
数组类型 数组名去掉就是数组类型 int arr[10] 数组类型 int[10]
结构体类型 struct
枚举类型enum
联合类型


指针类型
int* pi;
char* pc;
float* pf;
void* pv;

空类型
void 表示空类型(无类型)
通常用于函数的返回类型,函数的参数,指针类型。

void* 指针可以接受任意类型的地址 但int型你用char型指针接收就会报错 practice_8.c 223行
例如 int a = 10; void* p = &a; 正确  int a = 10; char* p = &a;报错 :从int * 到char * 型的类型不兼容
void* 指针不能进行解引用操作

浮点型存储
根据国际标准IEEE(电气和电子工程协会)754 任意一个二进制浮点型V可以表示成
(-1)^S * M * 2^E
(-1)^S表示符号位,当S=0 V为整数,当S=1 V为负数
M表示有效数字,大于等于1，小于2 因为是二进制 满二进一了
2^E表示指数位
IEEE 754规定:对与32位的浮点数,最高的1位是符号位S，接着的八位是指数E，剩下的23位为有效数字M



代码及其他解释 放在practice_7.c
下面四个代码的类型
int arr[5];// 数组
int *parr1[10];// 指针数组 由于[]优先级大于* 所以还是数组 数组名 parr1 数组类型int*  数组有十个元素 每个元素的类型是int*
int (*parr2)[10];//数组指针 该指针指向了一个数组 数组有10个元素 每个元素的类型是int
int (*parr3[10])[5];指针数组 数组名:parr3 有10个元素 每个元素是一个数组指针 该数组指针指向的数组有五个元素，每个元素是int型
//上面的数组最终是一个十行五列的二维数组

回调函数
回调函数就是一个通过函数指针调用的函数,如果你把函数的指针(地址)作为参数传递给另一个函数
当这指针被用来调用所指向的函数时，我们就说这是回调函数。
回调函数不是由该函数的实现方直接调用,而是在特定的会见或条件发生时由另外的一方调用的
用于对改事件或条件进行响应
practice_7.c 561行 
practice_8.c  22行

//qsort(库函数)- 可以排序任意类型的数据
//qsort 库函数 -quick sort 快速排序  practice_8.c 62行

char *ret = strstr(p1, p2);//在p1指向的字符串里查找是否存在p2指向的字符串
//首先ret的值等于这个函数返回来的值,其次char *ret是个字符指针 接收这个函数返回来的地址

	int* c = 0;
	int a = 9;
	c = a;
	printf("%d\n",c);//9

	等同于 
	int * c= 9
	printf("%d\n",c);//9
想给自己说的是什么意思呢? 在2021/10/17时我的理解是:首先c是先被赋值 再指向其他事物的地址
你看像下面这一小块代码 他是把c的值赋值成一个地址 所以必须解引用 所以在c本身不是地址 就可以直接用。
若理解有错误,必将更正 真的感觉有时候自己眼高手低 学废乐 学废乐 hahaha 我想啸！！！
	int* c = 0;
	int a = 9;
	c = &a;
	printf("%d\n",*c);

return 有终止函数的作用 当有多个return 满足条件 第一个return后 函数就停止了 其他的return就不会再返回了

practice_10 532结构体进阶

practice_10 754-802 位段
practice_10 804 枚举
C语言源代码--预编译(预处理)--->编译---链接---->可执行程序

文件保存数据相对于数据库来说:
1:不安全
2:占用更多空间
*/


